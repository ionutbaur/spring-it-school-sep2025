package com.itschool.springapp.service.impl;

import com.itschool.springapp.entity.Order;
import com.itschool.springapp.entity.User;
import com.itschool.springapp.exception.UserNotFoundException;
import com.itschool.springapp.model.OrderDTO;
import com.itschool.springapp.repository.OrderRepository;
import com.itschool.springapp.repository.UserRepository;
import com.itschool.springapp.service.OrderService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

@ExtendWith(MockitoExtension.class) // annotation that tells JUnit to use Mockito for this test class. Mockito won't work without this.
class OrderServiceImplTest { // test class for OrderServiceImpl, recommended *Test suffix to be recognized by JUnit. No need to be public, same for test methods.

    // helper constants for tests
    private static final long USER_ID = 123L;
    private static final String ORDER_ID = "fake order id";
    private static final String ORDER_ID2 = "fake order id2";
    private static final String REQUESTED_ORDER_DESCRIPTION = "fake requested description";
    private static final String DB_ORDER_DESCRIPTION = "fake DB description";
    private static final String DB_ORDER_DESCRIPTION2 = "fake DB description2";

    @Mock // annotation that tells Mockito to create a mock (fake/simulated) object of the OrderRepository class
    private OrderRepository orderRepository;

    @Mock
    private UserRepository userRepository;

    @Mock
    private User user;

    private OrderService orderService;

    @BeforeEach // annotation that tells JUnit to run this method before each test method
    void setUp() {
        orderService = new OrderServiceImpl(orderRepository, userRepository);
    }

    @Test // annotation that tells JUnit this is a method that executes a test
    void findAllOrders() {
        // ---------- start needed preconditions ------------

        // when the method findByUserId is called with the USER_ID as an argument, it should return our list of orders (getAllOrderEntities()) instead of querying the database
        Mockito.when(orderRepository.findOrdersByUser_Id(USER_ID))
                .thenReturn(getOrderEntities()); // return a list of 2 Order objects when called with USER_ID

        // ---------- end needed preconditions ------------

        // we call the method we want to test
        List<OrderDTO> allOrders = orderService.findAllOrders(USER_ID);

        // ---------- verify the results ------------

        // we start by verifying if the method's returned list of OrderDTO objects has the same size of the simulated list (getAllOrderEntities)
        assertEquals(2, allOrders.size());

        // we verify that the OrderDTO objects have the same id and description as the Order objects in the list we created (getAllOrderEntities)
        OrderDTO orderDTO1 = allOrders.getFirst();
        assertEquals(ORDER_ID, orderDTO1.id());
        assertEquals(DB_ORDER_DESCRIPTION, orderDTO1.description());

        OrderDTO orderDTO2 = allOrders.get(1);
        assertEquals(ORDER_ID2, orderDTO2.id());
        assertEquals(DB_ORDER_DESCRIPTION2, orderDTO2.description());
        // ---------- end verify the results, end test ------------
    }

    @Test
    void placeOrder() {
        // ---------- start needed preconditions ------------

        // create a dummy OrderDTO object to be used as an argument for the OrderServiceImpl::placeOrder method
        OrderDTO orderToPlace = new OrderDTO(null, REQUESTED_ORDER_DESCRIPTION);

        Mockito.when(userRepository.findById(USER_ID)) // when userRepository.findById is called with USER_ID (123L)
                .thenReturn(Optional.of(user)); // then return an Optional containing the mocked user instead of hitting the database

        // create a dummy Order object to be returned by the orderRepository::save method
        Order savedOrderInDB = new Order(DB_ORDER_DESCRIPTION); // use a different description to ensure the returned description is from the database
        savedOrderInDB.setId(ORDER_ID); // add also a fake id (as it will be generated by the db in real scenario)

        Mockito.when( // when
                orderRepository.save( // orderRepository.save is called with
                        Mockito.argThat( // any Order object that matches the following conditions
                                order -> order.getDescription().equals(REQUESTED_ORDER_DESCRIPTION) && // description matches the requested description
                                        order.getUser().equals(user) // and user matches the mocked user
                        )
                )
        ).thenReturn(savedOrderInDB);
        // ---------- end needed preconditions ------------

        // ---------- execute the method to test ------------
        OrderDTO placedOrder = orderService.placeOrder(USER_ID, orderToPlace);
        // ---------- end execute the method to test ------------

        // ---------- verify the results ------------
        assertEquals(DB_ORDER_DESCRIPTION, placedOrder.description()); // ensure the description is the one from database
        assertEquals(ORDER_ID, placedOrder.id()); // check if the placed order received the expected ID extracted from database
        // ---------- end verify the results, end test ------------
    }

    @Test
    void placeOrder_userNotFound() {
        // we are mocking the userRepository::findById method to return an empty Optional<User> object - meaning the user is not found in db
        Mockito.when(userRepository.findById(USER_ID))
                .thenReturn(Optional.empty());

        // we expect that a UserNotFoundException is thrown because the user is not found in db
        UserNotFoundException exception = assertThrows(UserNotFoundException.class,
                () -> orderService.placeOrder(USER_ID, null)); // no need to pass a valid OrderDTO object in this case, as the exception will be thrown before the object is used

        // we check that various properties of the exception are the same as we expect
        assertEquals(HttpStatus.NOT_FOUND, exception.getStatusCode());
        assertEquals("User 123 not found in db!", exception.getReason());
    }

    @Test
    void findOrdersByDescription() {
        Order someOrder = createOrderEntity(ORDER_ID, DB_ORDER_DESCRIPTION);
        Mockito.when(orderRepository.findOrdersByDescription(DB_ORDER_DESCRIPTION))
                .thenReturn(List.of(someOrder));

        List<OrderDTO> foundOrders = orderService.findOrdersByDescription(DB_ORDER_DESCRIPTION);

        assertEquals(1, foundOrders.size());

        OrderDTO orderDTO1 = foundOrders.getFirst();
        assertEquals(ORDER_ID, orderDTO1.id());
        assertEquals(DB_ORDER_DESCRIPTION, orderDTO1.description());
    }

    // helper method to create a list of Order entities (simulating database records)
    private List<Order> getOrderEntities() {
        Order order1 = createOrderEntity(ORDER_ID, DB_ORDER_DESCRIPTION);
        Order order2 = createOrderEntity(ORDER_ID2, DB_ORDER_DESCRIPTION2);

        return List.of(order1, order2);
    }

    // helper method to create an Order entity with given id and description (simulating a database record)
    private Order createOrderEntity(String id, String description) {
        Order order = new Order(description);
        order.setId(id);

        return order;
    }
}